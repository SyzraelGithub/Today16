<script id="jQ001_empty" class="jQ001e"></script>
<!--<< onlineXHR VASITASI İLE YÜKLENDİ/1607301227 >>-->

<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-latest.js"></script-->
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.js"></script-->
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-1.11.1.min.js"></script-->
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-2.1.1.js"></script-->
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-2.1.1.min.js"></script-->
<!--
	http://code.jquery.com/jquery-latest.js
	ile 
	http://code.jquery.com/jquery-1.11.1.js
	birebir aynı ve 286 KB (293,072 bayt)
	http://code.jquery.com/jquery-2.1.1.min.js
	ise hem daha yeni hem de 82.2 KB (84,247 bayt)
	
	Ancak gördüğüm kadarıyla, iOS iPad 'de 2.1.1.min sorun çıkarıyor. (Tam denemedim)
-->
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-latest.js"></script-->
<!--
	1412141755_En azından Bir Süreliğine jquery-latest.js yerine jquery-1.11.1.min.js kullanmayı düşünüyorum
	Denemeyi yaptım. iPhone iOS WizNote 'da sayfa yükleme hızı gerçekten ciddi miktarda artıyor.
	Ancak contenteditable = 'true' iken yani edit modunda iken jQuery aktif olamıyor.
	PC ortamında bu sorun geçerli değil. Sadece iOS ortamında. 
	Bundan dolayı ben şimdilik tekrar latest 'dan devam etmeyi düşünüyorum. 
	---
	Tekrar kontrol ettiğimde bu problemin kendiliğinden çözüldüğünü gördüm. iPhone 'lardan beyaz olan
	problemsiz çalıştırdı. Geri dönüp siyaha baktığımda onun da düzeldiğini gördüm.
	Bundan dolayı, tekrar 1.11.1.min 'e geçmeyi düşünüyorum latest 'dan
	---
	Acaba bu problem yerelleştirmeden kaynaklanmış olabilir mi? Yani jQuery dosyasını yerel klasöre kopyalayınca
	bu problem çözülmüş olabilir mi? 
	4452d88c-bd8b-4d4c-a839-c4d7237c5c4b_128_files/jquery-latest[1].js gibi
	---
	Bu arada hiç diğer alternatifleri denemedim. Bunu da belirteyim. Mesela bir de jQuery Mobile opsiyonu var.
	Onun dışında Selective jQuery var. Bunları da hesaba katmak gerebilir ileride. 
-->
<script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-1.12.0.min.js"></script>
<!--script id="jQ001" type="text/javascript" src="http://code.jquery.com/jquery-latest.js"></script-->
<!--
	Bazen devre dışı kalıyor ya program tamamiyle, işte sanırım tesadüfen bile olsa, bunun nedeni
	jquery 'e refer eden script 'in yerelleştirilmiş linki kırılıyor. Bu tür durumları çözmenin bence
	en mantıklı yolu, jQ001 adıyla geçen link eğer kırık ise, bunu kontrol eden bir program bu sorunu
	çözer. 
-->
<!--
	Harici Yükleme
	Hem Online Hem Offline Çalışma
	gDrive veya başka ortak paylaşım dosyaları ile çalışma.
	Direk Harddisk 'e eklediğim dosyaların burada uzak link olarak gelmesi meselesi
	Komut Matrisi
	başka aklıma gelirse buraya yazacağım. 
-->
<!--
	Çeşitli gerekçelerle ki, şimdi burada bahsetmeyeceğim,
	eğer komut matrisini geliştirmek birinci önceliğe gelmiş ise, ve bunun için de, eğer matrisi çok boyutlu hale getirmek 
	seçeneğini seçmeyi düşünüyorsam, Bu durumda yapılacak bazı konular var. Bunlardan bahsetmek lazım.
	Şimdi öncelikle komut matrisini çok boyutlu hale getirmeyi düşünüyorsam gerçekten, ikinci parametre ne olmalı bunu düşünmek lazım.
	Acaba kodun tamamını mı barındırması lazım. Eğer bunu yaparsak, o zaman her aşamada tüm kodlar yüklenecek. 
	Bunun çok da mantığı yok aslına bakarsan. 
	Eğer kodun tamamını matriste bulundurmak istemezsek, o zaman birkaç seçenek var.
	Mesela bir web sitesinden, örneğin bizim siteden, veya google drive 'dan veri gelebilir. 
	Google Drive 'dan gelmesinin bazı artıları var. Direk yaptığın değişikliğin devreye girme şansı var.
	Bundan dolayı bu mantığı doğru buluyorum.
-->
<!--
	Tüm Comment 'leri hem Html hem js, hem singleline hem de multiline tek seferde silen ve kodu daha sadeleştiren bir 
	yöntem varsa, uygulamayı düşünüyorum. Ancak;
	Eğer yükleme hızının yavaşlamasının esas nedeni commentler değilse, esas yavaşlama nedeninin aslan payı
	yani %90 lık pay jQuery 'den veya başka gerekçelerden kaynaklanıyorsa, bu durumda, boş yere bununla uğraşmanın mantığı yok.
	Çünkü ileride belki o commentlerin varlığı da yaz.gun içinde işe yarabilir. Bir süre sonra eğer eski code mevcut OHIC.html 'den
	ciddi miktarda yabancılaşırsa, yaz.gun içindeki kodun ne işe yaradığını anlamakta güçlük çekebilirim. 
-->
<script id="jQ001_001">
//debugger;
var Tar, TarSib, oldTar;
var cssObj;
function getcssObj(defCol,WiNCol,entCol,finCol, hoICol, hoOCol) {
	var newcssObj = {};
	newcssObj.colors = {};
	newcssObj.colors.default = defCol;
	newcssObj.colors.current = newcssObj.colors.default;
	newcssObj.colors.WiNcapable = WiNCol;
	newcssObj.colors.enteringParam = entCol;
	newcssObj.colors.finishedParam = finCol;
	newcssObj.colors.hovInColor = hoICol;
	newcssObj.colors.hovOuColor = hoOCol;
	return newcssObj;
}
ProtoT_getWeek(); //Yukarı da alsan aşağı da alsan çalışıyor. Demek ki her türlü Sub/Function erken okunuyor.
/*
	1607301316
	Evet, ProtoT_getWeek 'ı yukarı alsan da, aşağı alsan da çalışıyor olabilir.
	Fakat, isToday, retGenDec_dDt 'i kullanıyor. 
	retGenDec_dDt ise getWeek kullanıyor. Onun için 
	getWeek 'in prototype 'a eklenmesi gerekiyor. 
*/
if (isToday()) {
	cssObj = getcssObj('LightGray','LightYellow','Pink','PaleGreen','WhiteSmoke','White');
} else {
	cssObj = getcssObj('DarkGray','DarkGoldenRod','Purple','DarkGreen','Silver','WhiteSmoke');
	if (document.body) {
		document.body.style.backgroundColor = cssObj.colors.hovOuColor; //'WhiteSmoke';
	}	else {
		/*
			Bu noktada document.body demek ki yok. 
		*/
		console.log('document.body == null vermiş');
		document.addEventListener("DOMContentLoaded", function(event) {
			console.log('document.body == null vermiş (eventlistener içinde)');
			if (document.body) {
				console.log('document.body == null verMEmiş (eventlistener içinde 2. deneme)');
				document.body.style.backgroundColor = cssObj.colors.hovOuColor; //'WhiteSmoke';
			}
		});
	}
	var allDivs = document.getElementsByTagName('div');
	for (var allDivsi = 0; allDivsi < allDivs.length; allDivsi++) {
		allDivs[allDivsi].style.backgroundColor = cssObj.colors.hovOuColor; //'WhiteSmoke';
	}
}
/*
	141008 'den sonraki HTML ICINDEKI CODE.html içinden geldi.Mihenk kabul edilebilir.
	---
	Ana Dosya bu. Diğerlerinin devamlılığı şüpheli buna inline bile dahil. Offline da.
	Bundan dolayı, benim mantığıma göre, artık burada çalışma yapılabilir.
	Çünkü, benim mantığıma göre artık bu code 'un Dağıtım Zorunluluğu neredeyse tamamen
	ortadan kalktı.
	---
	cmdArr 'da XHR için bir hazırlık gerekiyorsa yapılmalı. Bu fonksiyonlar dışarıdan gelmeli.
	Yalnız bununla ilgili bir konu var. Bana sorarsan, bu işlem başlamadan önce mevcut tüm kodlar
	alt scriptlere dağılmalı. AltScriptler farklı dosyalarda olmamalılar. XHR birden fazla sefer çalışmalı.
	İsimlerinin bir mantığı olmalı. ismine baktığında işlevi aşağı yukarı anlaşılmalı ve mümkünse,
	versiyonları da olmalı. Ancak,
	bu hazırlıklara başlamadan da cmdArr ile XHR arasında çalışma başlatılabilir. 
	İki durum da kafama yatıyor. 
*/
// Arama Yaparken 'WiNj' diye ara
/*
	Ben Sakıncası Yoksa Fonsiyonları içerikten ayırmak istiyorum artık. Bakalım Çalışacak mı? Deneyelim.
	Öncelikle böyle bir kaydetmem lazım. 1411232349
*/
function fncFontSize(fncParam) {
	var new_setTar_fontSize = parseInt(fncParam[0]);
	if (new_setTar_fontSize >= 12 && new_setTar_fontSize <= 72) {
		setTar_fontSize = new_setTar_fontSize;
	}
	return true;
}
function fncYapBil(fncParam) {
	console.log(fncParam[0] + '\n' + fncParam[1] + '\n' + fncParam[2] + '\n' + fncParam[3]);
	if (WiNcapable) {
		/*
			Öncelikle, Son en güncel Yap.Bil Dosyası nerede ona bakmak lazım.
			Şuan itibariyle \.Kay\Akı\Pln\Yap\Bil\4\RG\b\3h\2d\325\ en güncel klasör bu.
			Bu işlemlere devam etmeden önce,
			Klasör kısmı boş bırakıldığı zaman, ne olacağına karar vermek lazım. 
			Çünkü bu süreç devam ederken kesinlikle, klasör kısmının boş kalacağı Yap.Bil Adayları gelecek.
			---
			\.Kay\Akı\Pln\Yap\Bil\ fix geldikten sonra, ondan sonraki klasörlerde,
			yani 4\RG\b\3h\2d\325 'lerde hep son klasörü esas almayı planlayabiliriz.
			Veya 3h ve devamı için sadece sayalım. Çünkü daha derin sistematik değişiklikler olabilir.
		*/
		/*
			fldYapBil diye bir değişken veya matris gerekir diye düşünüyorum. Bu matris objDatabase.GetFolderByLocation ile çalışabilir.
		*/
	}
	return true;
}
var kphDefDocOut; //Table eklerken kolaylık olsun diye bunu yapıyorum //Geçici Kontrol Değişkenleri (Sonra Sil!) (veya Commentle!)
var kphDocOut; //Geçici Kontrol Değişkenleri (Sonra Sil!) (veya Commentle!)
var kphDefTblOut; //Geçici Kontrol Değişkenleri (Sonra Sil!) (veya Commentle!)
function fncKayParHar(fncParam) {
	function creNewNote() {
		var newNote = '';
		var docType = true;
		/*			1607211741 docType String kismini Array 'den olusturmaya karar verdim		*/
		var docTypeStrArr =[39,32,80,85,66,76,73,67,32,92,34,45,92,47,92,47,87,51,67,92,47,92,47,68,84,68,32,72,84,77,76,32,52,46,48,49,32,84,114,97,110,115,105,116,105,111,110,97,108,92,47,92,47,69,78,92,34,32,92,34,104,116,116,112,58,92,47,92,47,119,119,119,46,119,51,99,46,111,114,103,92,47,84,82,92,47,49,57,57,57,92,47,82,69,67,45,104,116,109,108,52,48,49,45,49,57,57,57,49,50,50,52,92,47,108,111,111,115,101,46,100,116,100,92,34,399];
		var docTypeStr = '';
		for (var docTypeStri = 0; docTypeStri < docTypeStrArr.length - 1; docTypeStri++) {
			docTypeStr += String.fromCharCode(docTypeStrArr[docTypeStri]);
		}
		if (docType) {
			newNote /*00*/ = '<!DOCTYPE html' + docTypeStr + '>';
		} else {
			newNote /*00*/ = '<!DOCTYPE html>';
		}
		newNote /*01*/ += '\n<html><head>';
		newNote /*02*/ += '\n<meta http-equiv=\"Content-Type\" content=\"text\/html; charset=unicode\">';
		newNote /*03*/ += '\n<!'+'--defaultCSS--'+'>';
		newNote /*04*/ += '\n<title><\/title>';
		var idStyArr = ['wiz', 'custom', 'css'];
		newNote /*05*/ += '\n\n\n\n<style type=\"text\/css\" id=\"' + idStyArr.join('_') + '\">';
		newNote /*06*/ += '\nbody\n{\n    font-family: \"Segoe UI\",Tahoma,Helvetica,Sans-Serif,\"Microsoft YaHei\", Georgia,Helvetica,Arial,sans-serif,??, PMingLiU,serif;\n    font-size: 10.5pt;\n    line-height: 1.5;\n}\nhtml, body\n{\n    \n    \n}\nh1 {\n    font-size:1.5em;\n    font-weight:bold;\n}\nh2 {\n    font-size:1.4em;\n    font-weight:bold;\n}\nh3 {\n    font-size:1.3em;\n    font-weight:bold;\n}\nh4 {\n    font-size:1.2em;\n    font-weight:bold;\n}\nh5 {\n    font-size:1.1em;\n    font-weight:bold;\n}\nh6 {\n    font-size:1.0em;\n    font-weight:bold;\n}\nimg {\n    border:0;\n    max-width: 100%;\n}\nblockquote {\n    margin-top:0px;\n    margin-bottom:0px;\n}\ntable {\n    border-collapse:collapse;\n    border:1px solid #bbbbbb;\n}\ntd {\n    border-collapse:collapse;\n    border:1px solid #bbbbbb;\n}\n\n<\/style>';
		var tyScr = ['\"text\/javascript\"'];
		/*
			Burada halen klasör \Wiz olarak duruyor. Bunun \WizNote değişmesi gerekmiyor muydu? Değiştirdim
		*/
		var paScr = ['\"file:\/\/\/C:\\Program Files (x86)\\WizNote\\WizTools\\htmleditor\\', 'todo.js\"', 'dragresize.js\"'];
		var idScr = ['\"wiz_todo_script_id\"', '\"wiz_img_resize_script_id\"'];
		var wsScr = ['\"unsave\"'];
		var csScr = ['\"utf-8\"'];
		newNote /*07*/ += '\n<script type=' + tyScr[0] + ' src=' + paScr[0] + paScr[1] + ' id=' + idScr[0] + ' wiz_style=' + wsScr[0] + ' charset=' + csScr[0] + '><\/script>';
		newNote /*08*/ += '<script type=' + tyScr[0] + ' src=' + paScr[0] + paScr[2] + ' id=' + idScr[1] + ' wiz_style=' + wsScr[0] + ' charset=' + csScr[0] + '><\/script>';
		var tySty = ['\"text\/css\"'];
		var idSty = ['\"wiz_img_resize_style_id\"', '\"wiz_todo_style_id\"'];
		var wsSty = ['\"unsave\"'];
		var wvSty = ['\"01.00.04\"'];
		newNote /*09*/ += '<style type=' + tySty[0] + ' id=' + idSty[0] + ' wiz_style=' + wsSty[0] + '>.wizimgdragresize {position: absolute;z-index: 1000;border: 1px solid black; background-color: white;} .wizimgdragresize-lt { cursor: nw-resize; } .wizimgdragresize-tm { cursor: n-resize;}.wizimgdragresize-rt {cursor: ne-resize;}.wizimgdragresize-lm {cursor: w-resize;}.wizimgdragresize-rm {cursor: e-resize;}.wizimgdragresize-lb {cursor: sw-resize;}.wizimgdragresize-bm {cursor: s-resize;}.wizimgdragresize-rb { cursor: se-resize; }<\/style>';
		newNote /*10*/ += '<style type=' + tySty[0] + ' id=' + idSty[1] + ' wiz_link_version=' + wvSty[0] + '>.wiz-todo, .wiz-todo-img {width: 16px; height: 16px; cursor: default; padding: 0 10px 0 2px; vertical-align: -10%;-webkit-user-select: none;} .wiz-todo-label { display: inline-block; padding-top: 8px; padding-bottom: 8px; line-height: 1;} .wiz-todo-label-checked { text-decoration: line-through; color: #666;} .wiz-todo-label-unchecked {text-decoration: initial;} .wiz-todo-completed-info {padding-left: 44px; display: inline-block; } .wiz-todo-avatar { width:20px; height: 20px; vertical-align: -20%; margin-right:10px; border-radius: 2px;} .wiz-todo-account, .wiz-todo-dt { color: #666; }<\/style>';
		newNote /*11*/ += '<\/head>\n\n<body>\n\n\n\n<\/body><\/html>';
		
		return newNote;
	}
	//alert(fncParam[0] + '\n' + fncParam[1] + '\n' + fncParam[2]);
	if (WiNcapable) {
		var kphLoc = '/.Kay/Par/Har/Gnl/frm/14/11/46/11'; //Bu şekilde olunca kabul etmiyor
		var kphLoc = '/.Kay/Par/Har/Gnl/frm/14/11/46/11/';
		var kphFld = objDatabase.GetFolderByLocation(kphLoc,true);
		var kphFiN = '14114611_Har';
		var kphDocQuery = objDatabase.DocumentsFromSQL("DOCUMENT_LOCATION='" + kphLoc + "' AND DOCUMENT_TITLE='" + kphFiN + "'");
		var kphDoc = null;
		if (kphDocQuery.Count > 0) { //Ne kadar Count varsa bunları length ile değiştirmem lazım. Count count length 3 ihtimal var.
			kphDoc = kphDocQuery.Item(0);
			var kphDefDoc = document.implementation.createHTMLDocument(kphFiN);
			kphDefDoc.documentElement.innerHTML = kphDoc.GetHtml();
			if (kphDefDoc.getElementById('tbl_dnm') == null) {
				kphDefDoc.body.innerHTML += '<table id="tbl_dnm"><tbody></tbody></table>';
			}
			var kphDefTbl = kphDefDoc.getElementById('tbl_dnm');
			var newRow = kphDefTbl.insertRow(0);
			
			var newCell0 = newRow.insertCell(0);
			var newCell1 = newRow.insertCell(1);
			var newCell2 = newRow.insertCell(2);
			var newCell3 = newRow.insertCell(3);
			var newCell4 = newRow.insertCell(4);
			/*
				Bunlardan  önce tarih ve saatin de gitmesi gerekir diye düşünüyorum.
			*/
			newCell0.innerHTML = document.title.substring(0,2) + '.' + document.title.substring(2,4) + '.' + document.title.substring(6,8);
			/*
				Bu şekilde yapınca yani,
				document.title.substring(0,2) + '.' + document.title.substring(2,4) + '.' + document.title.substring(6,8);
				yıl.ay.gün diye ekliyor. Bunu excel farklı algılıyor. Bundan dolayı gün.ay.yıl şeklinde gitmesini ileride uygun bulursak
				document.title.substring(6,8) + '.' + document.title.substring(2,4) + '.' + document.title.substring(0,2);
				şeklinde değiştirmen gerekecek.
			*/
			newCell1.innerHTML = TarSib.textContent.substring(0,5);
			newCell2.innerHTML = fncParam[0];
			newCell3.innerHTML = fncParam[1];
			newCell4.innerHTML = fncParam[2];
			
			kphDoc.SetHtml(kphDefDoc.documentElement.innerHTML);
			/*
				Outları buradan sonra koyacağım
			*/
			kphDefDocOut = kphDefDoc;
			kphDocOut = kphDoc;
			kphDefTblOut = kphDefTbl;
		} else {
			/*
				Öncelikle bu konuya girmeden önce gerçekten benim boş bir not 'tan ne anladığımdan emin olmam lazım.
				Buna ulaşmanın yolları ne buna karar vermem lazım. 
				Otomatize edilebilir mi? Buna karar vermem lazım. 
				Bunların hepsini tartışmam lazım. 
				Bu konu uzar gider. Burada yüzde yüz zorunlu olmamakla beraber yüklü miktarda bir es verme söz konusu.
				---
				Bunlara karar verip neden sonuç ilişkilerine bağlayarak ilerlemek lazım. 
				Bunu zaten şimdi yapmazsam, ileride tekrar yapmak zorunda kalacağım.
				---
				Bu olaya girmeden önce bir plan yapmazsak kaybolma ihtimalini yüksek görüyorum. 
				---
				Bir kaç Varyasyon ve Strateji
					1.)Boşboş bir not belirleyip, ondan sonra bu nota programın neler eklediğine bakabiliriz.
						1a.)Sonra bu eklenmiş olan notun bizim kendi notumuzla ne kadar benzer olup olmaığına bakarız.
							1ai.)Hatta ulaşım varsa, Document.ziw 'in standart içeriği ile bunun alakası var mı yok mı ona bakarız.
					2.)Bu konuyu ana gövdeden ayırmayı düşünebiliriz. Biz düz not olarak çalışırız. Gerisine kendisi karar versin.
						Bir fonksiyon yazarız. Bu fonksiyon içine documentElement gibi birşey alır. sonra biz ne muamele yaparsak bu func içinde yaparız program yoluna devam eder. 
							Tabi bu fonksiyon çağırılmalı mı çağırılmamalı mı bunu bilmiyorum. Yani hazır mı gelmeli, yoksa sonradan mı yüklenmeli.
								Sonuç itibariyle şu açığa çıkıyor ki istersek biz bu problemi erteleyebiliriz. Ancak ertelemek istemiyorum. Bence şimdiden çözülmesinde fayda var. 
					3.)Yeni bir not ekleyip, bu notu araştırabiliriz.
					4.)
				---
				C:\Users\PrtgTosh\Documents\My Knowledge\Plugins\Journal.Today\flds\_newNote {NEW!}
					Bir değiştirilmemesi gerek kalıp dosyalar klasörü olmalı. Bu klasörün içinde varyasyonlar olmalı
					---
					Bu varyasyonlardan bir tanesi new Note vasıtasıyla gelen code olmalı. 
					...\flds\_newNote {NEW!}\Sbln
					---
						İki tane oluşturdum. New Note ve Today.html 'den gelen. 
						Bir de önceden oluşmuş olan bir notun farklarına bakmak lazım
						---
						Ondan sonra ne planlıyorum?
						Bundan sonra bugün 21.11.14 de oluşturulmuş olan günlük notu temizleyip onun yaptıklarına da bakmak lazım
						varsa başka varyasyonlarında şablonunu çıkarmak lazım. 
						---
						Bundan sonra file: / / ile başlayan linklerin Wiz yerine WizNote içermesini sağlamayı planlıyorum.
						---
						Bu arada new Note alternetiflerini denerken iOS ortamında oluiturulmuş note 'un da bir şablonunu almak gerekir diye düşünüyorum.
					---
				bu klasörde toplayacağım
				Bu klasörde bir alt klasörleme mantığı oluşturmak lazım
							
			*/
			kphDoc = kphFld.CreateDocument2(kphFiN,'');
			kphDoc.Type = "document";
			kphDoc.UpdateDocument3("", 0);
			var kphDefDoc = document.implementation.createHTMLDocument(kphFiN); //Burada kphLoc demişim ama kphFiN demem gerekiyordu.
			var kphDefHtml = creNewNote();
			kphDefDoc.documentElement.innerHTML = kphDefHtml;
			//kphDefDoc.title = kphFiN; //Bunu Comment yukarıdaki satırı denemek istiyorum.
			/*
				Bu noktadan sonra, dosyanın içine girip bir liste hazırlamak gerekiyor. Bunun üzerinden çalışmak lazım. 
		
				if (kphDefDoc.getElementById('tbl_dnm') == null) {
					kphDoc.body.innerHTML += '<table id="tbl_' + kphFiN + '"><tbody></tbody></table>';
				}
			*/
			if (kphDefDoc.getElementById('tbl_dnm') == null) {
				kphDefDoc.body.innerHTML += '<table id="tbl_dnm"><tbody></tbody></table>';
			}
			var kphDefTbl = kphDefDoc.getElementById('tbl_dnm');
			var newRow = kphDefTbl.insertRow(0);
			
			var newCell0 = newRow.insertCell(0);
			var newCell1 = newRow.insertCell(1);
			var newCell2 = newRow.insertCell(2);
			var newCell3 = newRow.insertCell(3);
			var newCell4 = newRow.insertCell(4);
			/*
				Bunlardan  önce tarih ve saatin de gitmesi gerekir diye düşünüyorum.
			*/
			newCell0.innerHTML = document.title.substring(0,2) + '.' + document.title.substring(2,4) + '.' + document.title.substring(6,8);
			newCell1.innerHTML = TarSib.textContent.substring(0,5);
			newCell2.innerHTML = fncParam[0];
			newCell3.innerHTML = fncParam[1];
			newCell4.innerHTML = fncParam[2];
			
			kphDoc.SetHtml(kphDefDoc.documentElement.innerHTML);
			/*
				Outları buradan sonra koyacağım
			*/
			kphDefDocOut = kphDefDoc;
			kphDocOut = kphDoc;
			kphDefTblOut = kphDefTbl;
		}

		//alert('Kay.Par.Har|WiNcapable = true');
	}
	return true;
}
function fncWiNjsloadjs(fncParam) {
	alert(fncParam[0]);
	if (WiNcapable) {
		alert('WiNjs.loadjs|WiNcapable = true');
	}
	return true;
}
var elOut;		//Bunlar Silinecek
var thOut;		//Bunlar Silinecek
var elSibOut;	//Bunlar Silinecek
function fncDivAdd(fncParam) {
	/*
		mesela 17:23,4 girildi. Öncelikle 17:23 diye geçen bir div var mı? Onu bulacak.
	*/
	var divAdded = false;
	$.each($('body > div'), function(i, el){
		var elSib = getSib(el);
		/* 1607301205 getSib 'e fonksiyonalize oldu
		var elChildNodeIndex = 0; 
		if (el.childNodes[elChildNodeIndex].nodeType == 3) {
			elChildNodeIndex++;
		}
		if (el.childNodes[elChildNodeIndex].color == '#0000ff') {
			elSib = el.childNodes[elChildNodeIndex].childNodes[elChildNodeIndex].childNodes[elChildNodeIndex];
		} else {
			elSib = el.childNodes[elChildNodeIndex].childNodes[elChildNodeIndex];
		}
		*/
		if (elSib.innerText.substring(0,5) == fncParam[0]) {
			if (!divAdded) {
				divAdded = true;
				elOut = el;
				thisOut = thOut;
				elSibOut = elSib;
				var dHourExt = elSib.innerText.substring(0,5).substring(0,2);
				var dMinuteExt = elSib.innerText.substring(0,5).substring(3,5);
				var defDivExt;
				if (defDivExtYeniUsul) {
					autLsynF = function(urlF) {
						with (new XMLHttpRequest()) {open('GET',urlF,false);send();return responseText}
					}
					getPF = function() {
						if (typeof urlPF != 'undefined') {
							return urlPF
						} else {
							return 'https://dl.dropboxusercontent.com/u/31117393/h1/iPlg/Today16/'
						}
					}
					autLsynHDoc = function(urlLF) {
						urlF = getPF()+ urlLF + '.htm';
						var docF = document.implementation.createHTMLDocument('');
						docF.documentElement.innerHTML = autLsynF(urlF);
						return docF;
					}
					var inBodyDoc = autLsynHDoc('defDivOld');
					with (inBodyDoc.getElementsByTagName('span')[0]){
						innerText = innerText.replace('00',dHourExt);
						innerText = innerText.replace('00',dMinuteExt);
					}
					defDivExt = inBodyDoc.body.innerHTML;
					//Daha bitmedi dHourExt ve dMinute Ext 'i de alacak. Replace ilk Occurance 'ı alıyorsa,
					//Burada sırayla çalışır.
				} else {
					defDivExt = '\n\t<div>\n\t\t<font face=\"Segoe UI\" color=\"#00' + '00' + 'ff\">\n\t\t\t<b>\n\t\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">' + dHourExt + ':' + dMinuteExt + ' A...<\/span>\n\t\t\t<\/b>\n\t\t<\/font>\n\t<\/div>\n\t<div>\n\t\t<font face=\"Segoe UI\">\n\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">a...<\/span>\n\t\t<\/font>\n\t<\/div>';
				}
				$(el).next()[0].outerHTML += Array(parseInt(fncParam[1])+1).join(defDivExt);
			}
		}
	});
	return divAdded;
}
var cmdArr = [
	/*
		Burada bir detaydan bahsetmek istiyorum. Eğer istenirse sadece parametre adedini değil aynı zamanda parametrenin ne olduğunu da ekleyebiliriz.
		Örnek vermek gerekirse mesela, Diyelim ki, Kay.Par.Har yazıldı. Burada ilk parametre KK mi NK mi seçeneği. 
		Kullanıcı tarafına bunu hatırlatmak unutmalara karşı işe yarayabilir. Bundan dolayı,burada Kay.Par.Har('"' olmasında ise şu olabilir.
		Kay.Par.Har('KK mı NK mi?:'"'KK'"'Mebla?:'"'35'"'Harcama Açıklaması?:'"'Yemek yedik.'"')
		şeklinde olursa, Hangi datanın girilmesi gerektiğinin unutulma ihtimali de önlenmiş olur.
		---
		Bunun başka seçenekleri de olabilir. Belirli bir zaman geçtikten sonra, kullanıcı kayıt girmezse, kararsız kaldığı da varsayılabilir.
		Onun dışında, WiN ortamında mouse hover halindeyken Hint/ipucu şeklinde gecici olarak abbr tag gibi gözükmesi sağlanabilir.
		Bunlar da zaman ve imkan olduğunda düşünülebilir opsiyonlar arasında sayılabilir. 
		---
		Eğer bu şekil bir çalışmaya girersek, o zaman aşağıdaki satırlardan bir tanesi şu şekilde olacak,
			'Kay.Par.Har', [3, fncKayParHar], 
			'Kay.Par.Har', [[3, ['NKmiKKmi', 'Mebla', 'Aciklama']], fncKayParHar],
	*/
	/*
		cmdArr istek köşesi. Burası istek köşesi olsun
		---
		İstek 1.)
			Haftalık veya aylık günlük notları, tek seferde oluşturmanın cmdFnc 'si yazılabilir mi?
			Normalde günlük dosya oluşturmak fonksiyonalize edilmeden bu sağlanamaz. Eğer bu sağlanacaksa da, bu ancak ve ancak,
			Today.html dosyasında sağlanabilir diye düşünüyorum.
				---
				Today.html dosyasında GenDec_dDt fnc istediğimiz altyapıyı sağlıyor. Sadece buna ilaveten kaç günlük bir süreklilik isteniyorsa
				o kadar i++ ile şu komut yazılacak. tomorrow.setDate(today.getDate()+1);
				http://stackoverflow.com/questions/563406/add-days-to-datetime
	*/
	'Font.Size', [1, fncFontSize], 
	'Yap.Bil', [4, fncYapBil], 
	'Kay.Par.Har', [3, fncKayParHar], 
	'WiNjs.loadjs', [1, fncWiNjsloadjs],
	'Div.Add', [2, fncDivAdd]
	/*
		Ortak fnc olayı bence birçok ihtiyacı giderir. Ortak fnc 'nın amacı şu, diyelim ki herhangi yeni cmdPhrase ekleyeceğim. Hatta diyelim ki,
		birden fazla ekleyeceğim. Bunların hepsinin işleyişi ise basit anlamda kayıt tutmak olsun mesela. Örneğin, içtiğin sigara gibi veya mbtus gibi.
		Veya diyelim spor faaliyetleri gibi. O zaman işte bunlar sonuçta gidip bir yerlere liste halinde yazıyorlar.
		Bu tür durumlarda öyle bir fnc düşün ki, fnc 'ye önden hangi klasöre gideceği, o klasörde hangi nota gideceği ve o nota ne yazacağı da belirtiliyor.
		Belirtiliyor derken, parametre olarak belirtiliyor. Ondan sonra, program gidiyor, o klasöre ve o nota istenen şekilde eklenen data 'yı ekliyor.
		Bu şekilde bir mantık oluşturursak, hızlı bir şekilde yeni cmdPhrase 'ler eklenebilecek. Ancak bu yapıldığında otomatikman bazı konular
		daha fazla önceliğe gelmiş olacak.
			1.)İstenen datanın ne olduğunun belirtilmesi daha önemli hale gelecek. Mebla? KK mı NK mı gibi?
			2.)Önceki günlerdeki verinin de hasat edilmesinin otomatize edilmesi elzem hale gelecek.
				Bu arada aklıma gelmişken, bu cmdArr bu şekilde genişlerken, girilmiş olan bir cmdInstance 'ın önceki günlerde de taranması gerekmesi daha
				elzem hale gelecek. Bundan dolayı şimdiden bununla ilgili bir hazırlık yapmakta fayda var.
			3.)Belki cmdArr elemanlarının yapısının değişmesi gündeme gelecek.
				'Kay.Par.Har', [[3, ['NKmiKKmi', 'Mebla', 'Aciklama']], fncKayParHar],
		---
		Hatta çok ileride yeni cmdPhrase 'ler ekleyen bir cmdPhrase ve cmdFnc de olabilir. Yani kullanıcı tarafında da yeni kayıt tutma cmdPhrase 'leri
		eklemenin yolları açılmış olabilir. Ancak bu çok daha ileriki bir aşamada düşünülecek bir konu. Şimdilik, bunun altyapısını sağlamayı düşünmek için
		bile erken.
	*/
];
/*
	command Matrisi geliştirmek konusunda birden fazla çözüm var. Bunların hangisi mantıklı hangisi mantıksız bilmiyorum. Ancak ben indexOf konusunda
	kararlıysam ve kendi multi-dim indexOf yapmayı düşünmüyorsam, o zaman en mantıklı çözüm, komutu ve fonksiyonu ardışık kullanmak diye düşünüyorum. Bu şekilde ilerleyeceğim şimdilik. 
	
	Şimdi bu arada, bazı gerekçelerle, window.external kontrolünden WiNcapable 'a geçmem gerekiyor. Bunun nedenlerini burada açıklamak gerekir aslında.
	Ancak hepsi aklıma gelmeyebilir diye düşünüyorum. Öncelikle window.external gerçeği yansıtmıyor. iOS ortamında da bir window.external var.
	Ancak başka bir object. Bundan dolayı, komple kontrol gerekiyor. Ancak bunun için de öncelikle şuna karar vermek lazım. objApplication, objDB gibi
	objeler Global mı olacak? Global olmazsa ne olur? RGB.246.html 'de global. Biz de Global yapalım. 
*/
/*
	Ben artık Sadece parametrelerin ' tırnak işareti içine girilmesini değil aynı zamanda Onun talep ettiği değerin 
	Ne değeri olduğunun girilmesi gerektiğini düşünüyorum. Ancak bunun alt yapısını kurgulamak bir hayli zor.
	Normalde bu konuya girmeden önce, şunu da belirtmek lazım.
	fncParam değil fncObj gibi bir object döndürülmesi lazım. Bu objenin çeşitli Property 'leri olması lazım.
	Bu Property 'ler vasıtası ile değerlerin çekilebilmesi lazım. Bunun mantığını kurgulamak şu anda zor olabilir.
	Yani Normalde örneğin 3 parametreli bir cmdInstance girildiğinde,
	Diyelim ki Kay.Par.Har örneğin. KK/NK/?? yazacak ona sen KK yazacaksın. Ardından Mebla yazacak.
	Sen meblayı yazacaksın. Sonra da nerede harcandığı yazacak.
	---
	Bu olaylara girmeden önce, öncelikle, boşluk girme probleminin çözülmesi lazım.
	Aynı zamanda ' tırnak işareti probleminin de çözülmesi gerekiyor. Bunları nasıl halledeceğim?
	Şu anda bunlar belli değil. 
	---
	Normalde bence bu konuları Enter/Return/Geç(iOS) çözer. 
	Geç veya enter tuşuna basıldığında bir sonraki parametreye girdiğimi anlamasını sağlarsak eğer,
	o zaman veri girişi hızlanabilir. 
	---
	Ancak bundan önce AutoComplete özelliği de eklebilir.
	Hatta istersen, autoComplete özelliğinin parametre girilmesi esnasında değişmesi de sağlanabilir.
		---
		Yani buradan kastettiğim şey şu;
		Mesela k 'ye bastığında Kay. çıktı. Bastığında anda Par. çıktı. Seçince
		Har. da çıktı ve hatta parantez açıldı ve kapandı (diyelim mesela)
		Ardından aslında girilecek çok parametre var. Ancak bunlardan sadece 3 tanesi elzem.
		Ama aslında 8 parametre var. 
		T 'e basınca Tür: çıktı. Sen KK yazdın. M ' e bastın Mebla çıktı. Arından N 'e bastın Neye veya Nereye
		çıktı. Yazdın. 3 elzem parametreyi tamamladın ama bir enter 'a daha bastın. Sonra gitti.
		---
		Yalnız bu şuanda çok fantezi oluyor. Bence öncelikle şu boşluk problemine bakmak lazım.
		Veya en azından tırnak işareti problemine bakmak lazım. 
	---
	İstersen tırnak işareti artık '"' olsun veya "'" olsun mesela.
	---
	Şimdi sanki, 2 konu bir miktar bile olsa bir anlamda berraklığa ulaştı. 
	Bunlar 1 tanesi mutlaka hem parametre içindeki hem de dışındaki boşluk bırakmama zorunluluğu 
	giderilecek. Ayrıca tırnak tuşuna basma zorunluluğu ortadan kaldırılıp,
	bu enter tuşu ile değiştirilebilir hale gelecek. 
	
*/
var setTar_fontSize = 24;
/*
	Bence en azından sadece dDate Genelde Declerate edilmeli. Yoksa program Sorun yaratacak
*/
var dDate;

var objApp,objWizDoc/*Sonradan Eklendi*/,objDatabase,objWindow,objDoc,objDocHtm;
var WiNcapable = false;
var WiNcapStr = ['WiNcapable', 'true', 'false', 'Not', 'Processed', 'created', 'Win', 'iOS', 'ltPrcS01S'];

var TarSibOut; //Geçici Kontrol Değişkenleri (Sonra Sil!) (veya Commentle!)
var elProcOut; //Geçici Kontrol Değişkenleri (Sonra Sil!) (veya Commentle!)

function GenDecIfTypeOf() { //WizDocument eklendi
	objApp = window.external;
	if (typeof objApp == 'object') { //editMode anlaşılabilir objWizDoc 'tan
		WiNcapable = true; 
		if (typeof objApp.Database == 'object') {
			objDatabase = objApp.Database;
			objWindow = objApp.Window;
			if (typeof objWindow == 'object') {
				objDoc = objWindow.CurrentDocument;
				objDocHtm = objWindow.CurrentDocumentHtmlDocument;
				WiNcapable = true;
			}
		} else {
			objWizDoc = objApp.WizDocument;
			objDatabase = objWizDoc.Database
		}
	}
};	GenDecIfTypeOf();

function ProtoT_getWeek() {
	Date.prototype.getWeek = function() {
		var onejan = new Date(this.getFullYear(),0,1);
		return Math.ceil((((this - onejan) / 86400000) + onejan.getDay()+1)/7);
	} 
}

function twoDigit(digit) {
	digit = '' + digit;
	if (digit.length < 2) {
		digit = '0' + digit;
	}
	return digit;
}

function retGenDec_dDt() {
	dDate = new Date();
	var dYear = twoDigit(dDate.getYear()-100);
	var dMonth = twoDigit(dDate.getMonth() + 1);
	var dWeek = twoDigit(dDate.getWeek());
	var dDay = twoDigit(dDate.getDate());
	var dWay = twoDigit(dDate.getDay());
	var dHour = twoDigit(dDate.getHours());
	var dMinute = twoDigit(dDate.getMinutes());
	if (dWay == 0 || dWay == 6) {
		dWeek-=1;
		/*
			Sadece haftanın 2 günü boyunca bu problemin kaynaklanmasının nedenini sanırım sonunda buldum.
			twoDigit fnc gayet düzgün çalışıyor. Ancak dWeek-1 olduğunda tekrar string 'ten integer 'e dönüşüyor.
			Bunu yaptığında, başındaki 0 gidiyor. Bundan dolayı twoDigit 'in anlamı kalmıyor.
			Bunu çözmenin en kolay yolu, sonucu tekrar twoDigit 'e çevirmek
		*/
		dWeek = twoDigit(dWeek);
	}; 
	return dYear + dMonth + dWeek + dDay;
}

$(document).ready(function () {
	$('div').hover(hovIn, hovOu);
	$('div').each(function () {/*Burada Selector olarak direk Body > Div denebilirdi. O zaman parentNode == Body sorgusuna gerek kalmazdı*/
		if ($(this).get(0).parentNode.nodeName == 'BODY' && 
			$(this).get(0).style.border == '1px dashed gray') {
			$(this).css('background-color', cssObj.colors.hovOuColor);
			$(this).css('border', 'none');
		}
	});
	/*
		Bence eğer açılışta bütün yazıların aynı boyda olmasını istiyorsak, bunu document.load 'ın içinde yapmak lazım.
		Bunun dışında, $.each ile yapmak gerek diye düşünüyorum. setTimeOut koymak lazım diye düşünüyorum. 
		Bu şekilde yaparsak mantıklı olacağını düşünüyorum.
	*/
	$.each($('body > div'), function(i, el){
		setTimeout(function(){
			if (Tar != el) {
				$(el).find('span').animate({fontSize: "12px"}, 100);
			} else {
				$(el).find('span').animate({fontSize: "15px"}, 100);
			}
			//
			//	Eğer Tar ise el yani şuan cursor o div üzerindeyse, onu ufaltmamalı.
			//	Ayrıca o div 'in zaten 12 punto olması halinde code 'un çalışmaması gerekir.
			//
			
			//	1602201612
			//	normalde 100 ms de çalışıyor. Ancak, benim ScrollTop ile çatışma yaşadığına dair şüphem var.
			//	bunu 10 ms ye düşürmeyi düşünüyorum.
			//
		},100 + ( i * 100 ));
	});
	$.each($('span#' + WiNcapStr[0] + '_' + WiNcapStr[2] + '.' + WiNcapStr[8]), function(i, el){
		setTimeout(function(){
			if (WiNcapable && document.body.contentEditable == 'true' /*Yoksa Edit Demeden işleme başlatıyor*/) {
				elProcOut = el; //elProcOut.parentElement.innerText.split(')')[0]
				//alert('Normalde' + el.parentElement.innerText.split(')')[0] + 'Tekrar işleme girecekti');
				cmdTxtJob(el.parentElement);
				/*
					İkinci sefer bu işleme girdiğinde başarılı olursa eğer WiNcapable_false 'u WiNcapable_true ile değiştirmeli.
					Ancak bunun için daha code yazmadım. 
				*/
				/*
					Tam gözlemleyemedim fakat ilginç bir konu var. Sanırım kendilğinden çözülecebilecek bir mesele ama yine de ben söyliyim. 
					Mesela diyelim ki iOS olanlar WiN 'e dönüştü. Ondan sonra kaydedince, tekrar nota geri döndüğümde, tekrar iOS gibi 
					gözüktüklerini görüyorum ancak işleme sokmuyor. Bunun birden fazla nedeni olabilir.
						1.)Kullanıcı eliyle klavye vs tarafından giriş olmadığı için, önbellekteki kopyayı tekrar gösterip arka planda
						değişmiş olan HTML geliyor olabilir.
						2.)Kullanıcı tarafında klavye ile değişiklik veya text anlamında değişiklik olmadan değişiklik olsa bile
						save edince bunu yok sayıyor olabilir.
						3.)Programsal olarak bir sorun olabilir. 
					---
					Yan Çözümler:
						---
						Şimdi öncelikle nasıl olsa benim bir Accordion programım var. Öncelikle bu Accordion programını tekrar aktif edip,
						Ondan sonra, bir cmdPhrase haline dönüştürebiliriz. Bunu sağladıktan sonra, bunu uygun bir cmdPhrase haline 
						dönüştürdükten sonra, bunu parametric hale getiririz. Ondan sonra da bu sorgunun koşullu olmasını sağlayabiliriz. 
						Bunların hepsi sağlandığında, sadece içinde iOS class lı notların Accordion 'nun yapılmasını sağlayabiliriz.
						Bu da sağlandığında, kullanıcı tarafında sadece pending iOS class 'lı notlara kolay ulaşım sağlarız.
						Gerekirse, daha yol yakınken onları el ile temizleriz. Böylece başka problemler yaşamayız.
						---
						Bunun yanında eğer istenirse, tek seferde, tüm WiN ' e dönüştürülmüş işlemlerin tekrar iOS 'a dönüşmesinin sağlarız.
						Böylece tepkisellik tekrar tekrar kontrol altına alınabilir. Hatta bu tepkisellik kontrolü amaçlı WiN 'den iOS 'a
						dönüştürme fnc 'sinin bir cmdPhrase olmasını bile sağlayabiliriz. Bunların hepsi imkanlar dahilinde olabilir.
						---
						GUID gibi bir çözüm sisteme dahil olduğunda bunların hiçbirine ihtiyaç olmayabilir veya çok daha az ihtiyaç olabilir.
						Bu şartlar altında başlangıçta aşırı külfet gibi görünün GUID meselesi tam aksine kolay çözüm haline gelebilir.
						Veya bu durum bizi tüm sistemi daha kolay ve basit bir şekilde kurgulamaya itebilir. Bu şekilde bile olsa, uzun vadede
						faydalı olacaktır bu değişim. Çünkü bunu denemeden bunu görme/öngerme olasılığı çok düşüktü zannımca. 
				*/
			}
		},100 + ( i * 100 ));
	});
	
	/*
		1602202006
		---
		Aynı code window.load içinde olmasına rağmen problem olacağına inandığım için,
		scrollDown code 'unu buraya da yazacağım. Böylece nereden tetiklenirse tetiklense en az bir defa
		Denk gelme ihtimalini arttıracağım. Ancak, bunu yapmadan önce, bir yerlere nereden tetiklendiğini
		yazmasını isteyebilirim. Veya mümkünse beep gibi bir fnc veya bunun dışında şu da olabilir.
		ilk div arka plan rengini değiştirebilirim mesela. Veya daha güzeli aktif olan div de olabilir.
		---
		Şimdilik sadece değişiklik scrollDown hızını düşürmekle belli olsun.
		---
		1602212109
		Sonradan kaldırdım o kodu. $(window).load( ile başlayan animate code unu buradan kaldırdım.
	*/
	
	
});

$(window).load(function() {
	/*
		1602201458
		Bu animate olayı çalışıyor fakat. Ben bunun WiNcapable değilken ve edit mode da iken çalışmasını isteyebilirim.
	*/
	$("html, body").animate({ scrollTop: $(document).height() }, 1000);
});

/*
	1602221320
	Aslında bu scrollDown olayı çok da iyi bir çözüm ile bağlanmadı. Palyatif bir çözüm ile bağlandı.
	Bundan dolayı ileride problem yaratırsa ve tekrar çözüm gerekirse, jQuery e ihtiyaç duymayan bir code olmalı
	setInterval içerebilir. içerse iyi olur. Bunun dışında, bir de editMode a yani contentEditable a ve
	WiNcapable a bağlı olsa yani onları kontrol edip ona göre çalışsa daha iyi olur diye düşünüyorum.
*/

/*
	Eğer ileride Sayfa yeni açıldığında mevcut cmdArr var ise sayfada, önceden yazılmış olan, 
	bunların işleme sokulması ile ilgili bir çalışma yapmam gerekirse,
	bu altyapının bence document.ready içinde ve $.each şeklinde settimeout ile
	olması gerektiğini düşünüyorum. 
	---
	Font.Size('15') var diyelim mesela, Sayfa tekrar açıldığında kursörün tekrar buraya
	gelmesini beklemeye gerek var mı bilemiyorum. 
	---
	Ancak bu arada bir konu daha var.
	Kay.Par.Har('KK','15','Yemek') diye bir kayıt girildi mesela. 
	Bunun her açılışta tekrar işlenmesi ne kadar mantıklı? 
	Bundan dolayı, işte burada processed takısı çok işe yarar diye düşünüyorum. 
	Eğer processed takısı var ise, demekki tekrar tekrar işlemeye sokmaya gerek yok.
	Ancak mesela onStart takısı var ise, bu sefere açılıştı yapmak gerekir diye düşünüyorum. 
	Bu sefer istediğimiz id' yi ararız direk.
	---
	Bu duruma özgü bir class ve id bulmak gerekiyor. Bu id ve class programın
	ne yapacağına karar vermesini sağlayacak. Bu mantık fena gözükmüyor. Opsiyonellik maksimum olmuş olur böylece.
	---
	Hatta daha da ileriye gidip, şunu da düşünebiliriz. Optional Param 'ları, html tag ları şeklinde tutmak da 
	fena fikir gibi gözükmüyor.
*/

function hovIn() {
	if ($(this).get(0).style.border != '1px dashed gray') {
		$(this).css('background-color', cssObj.colors.hovInColor);
		$(this).css('border', '1px dotted Silver');
	}
}

function hovOu() {
	if ($(this).get(0).style.border != '1px dashed gray') {
		$(this).css('background-color', cssObj.colors.hovOuColor);
		$(this).css('border', 'none');
	}
}

//$(document).bind('keyup keydown click', function (e) {  
/*
	Performans gerekçeleriyle keydown 'u kaldırdım. Ancak daha önce bunu denediğimde, bir problemden dolayı, 
	kaldırmamayı seçmiştim. Şimdi görüyorum ki, özellikle yazdıklarım uzayınca yavaşlık başgösteriyor.
	Neden keyup 'ı değilde keydown 'ı kaldırdın dersen, aslında hiçbir fikrim yok.
	Sadece tuş basıldıktan sonra daha kesin sonuç alacağımı düşünüyorum.
	---
	Aslında bunun bir yolu daha var ama şuan buna hazır olduğumu sanmıyorum. O da şu,
	hepsi için ayrı function paketleri hazırlamak olabilir. Yani mesela diyelim ki user activity olarak,
	keydown, keyup ve click eylemlerinde yapılmasını istediğim toplam 20 function bir kısmı birinde
	bir kısmı birinde bir kısmı hepsinde veya sadece ikisinde gibi..
*/
/*
	Enter tuşunu takip etmek istiyorsam, kuvvetle muhtemel bu e değişkeninden çıkmam lazım.
	Ancak e değeri iOS ortamında Enter tuşu ile WiN ortamında e değeri değişebilir.
	Bundan dolayı bu denemeyi iki ortamda da denemek gerekebilir.
*/
/*
	Ben enter tuşunun aktivitelerini takip etmek istiyorsam anladığım kadarıyla bunu keyup event 'ı ile değil
	keydown event 'ı ile yapmam gerekiyor. Bundan dolayı, burada bir seçenek durumu ile karşı karşıyayız diyebiliriz.
	Bunlardan bir tanesi belki en kolayı ama en doğrusu mudur bilemiyorum, 'keyup click' yerine 'keydown click' koymak
	Ancak bana sorarsan, keyup 'ı keydown ile değiştirmek ilave problemlere neden olabilir.
	---
	Bundan dolayı, bence mevcut olan 'keyup click' e karışmayıp, bunun yerine keydown yapmak mantıklı olabilir.
	keydown 'ı koyduğumda, keydown a yeni fonksiyonlar eklemem gerekecek. Yeni code 'lar
	Bu defa aynı kodun 2 defa çalışmasına neden olma ihtimalim de var. Bu durum keyup ve click için geçerli değil.
	Çünkü biri mouse 'dan biri klavyeden tetikleniyor.
	---
	Bu açıdan sadece tekrarlanma riski, keydown ile keyup arasında, Bundan dolayı bence bazı fonksiyonları komple
	keyup click 'ten çıkartıp direk keyup 'a almak daha mantıklı olabilir diye düşünüyorum. 
	---
	Yani bazı işlemler tuş basıldığında, bazı işlemler ise tuş kalktığında çalışsın diye düşünüyorum.
	Buna başladamadan önce mevcut code 'un detaylarına inmek lazım ki, ardından tasnif de doğru olsun.
	---
	Az önce yaptığım denemeler sonucu gördüm ki, iOS ortamında da Geç tuşu Enter gibi [13]{13} görevi görüyor.
	Bundan dolayı ben 13 'ü takip ettiğim sürece Enter olayını tamamlamış olacağım belli oldu.
	iOS ve WiN 'de Enter/Geç => [13]{13}
*/
/*
	1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
		var eOutDown; //e 'nin keyDown 'dan Out olanı
*/
/*
	veriAyiracOut ve veriAyirac aslına bakarsan, normalde klavye ile basılamayan karakterler de olabilir.
		0 = 
		1 = 
		2 = 
		3 = 
		4 = 
		5 = 
		6 = 
		7 = 
		8 = 
		9 = 	
		10 = 
		11 = 
		12 = 
		13 = 
		14 = 
		15 = 
		16 = 
		17 = 
		18 = 
		19 = 
		20 = 
		21 = 
		22 = 
		23 = 
		24 = 
		25 = 
		26 = 
		27 = 
		28 = 
		29 = 
		30 = 
		31 = 
	Bu karakterlerden biri ile de bu sağlanabilir diye düşünüyorum. Ancak bunlar biraz riskli de olabilir. Veya tam tersi,
	charCode 127 ile 160 arası da olabilir. charCode 161 ve sonrası da olabilr.
	Yani en azından böyle bir Opsiyonum olduğu da hatırda kalsın istiyorum.
*/
var veriAyiracOut = /*String.fromCharCode(39);*/ String.fromCharCode(39) + String.fromCharCode(34) + String.fromCharCode(39);

$(document).bind('keydown', function (e) {
	/*
		1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
			eOutDown = e;
	*/
	/*
		Başka seçenek olmadığı için, enter tuşunun suppress olma eylemini burada tamamlamam gerekiyor. Bundan dolayı
		en mantıklı çözüm, Herhangi bir cmdInstance 'a veri giriliyorsa, o esnada, enter tuşunun
		keydown içinde kontrol altına alınması.
			---
			Bu function 'ın içinde başka function içine yönlendirince de çalışıp çalışmayacağını şimdilik denemeyeceğim.
	*/
	if (e.keyCode == 13 /* || e.keyCode == 10*/ && enteringParamAra == true) {
		/*
			Bu noktadan sonra ayıraç ve virgül koyup devam etmesini sağlamak lazım.
				Normalde şunu kulanırdım
					locTarSib.innerText += '(' + veriAyirac;
				Ancak buna 3 engel var. 
					Birincisi veriAyirac global değil.
					İkincisi locTarSib olmak zorunda değil. Cursor 'un bulunduğu yer mutlak Tar 'dır locTar aracısına gerek yok.
					Üçüncüsü ise, cmdInstance yeni tamamlandığındaki kadar, cursor 'un sonunun istediğimiz yere denk gelme ihtimali yüksek değil.
						Buradan kastettiğim şey şu, Enter 'a bastığımda TarSib 'in innerText 'inin içinde Parantez sonrasında da birşeyşer olabilir.
						Veya parantez olmayabilir ancak .lateProcess olabilir.
						Veya .lateProcess de olamayabilir ancak yine de içinde önceden yazılmış birşeyler olabilir. 
				Bu ve bu gibi nedenlerden dolayı, innerText 'e += ile eklemek bana çok da mantıklı görünmüyor.
				Ancak yine de kolaylık olsun diye şimdilik bu şekilde gideceğim. Biraz da denemek istediğim için.
		*/
		if (enteringParamSon == false) {
			TarSib.innerText += veriAyiracOut + ',' + veriAyiracOut;
		} else {
			TarSib.innerText += veriAyiracOut + ')';
		}
		var sel = document.getSelection();
		sel.collapse(TarSib,1);
		/*
			e. ile ilgili aşağıdakilerinin hepsi gerekli mi şimdilik bilmediğimden hepsini koyuyorum.
				e.stopPropagation();
				e.preventDefault();
				e.returnValue = false;
				e.cancelBubble = true;
				return false;
		*/
		e.stopPropagation();
		e.preventDefault();
		e.returnValue = false;
		e.cancelBubble = true;
		return false;
  }
});
/*
	1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
		var eOutUpClick; //Bunun isminin eOutUp ile değişmesi gerekebilir veya eOutUpClick de olabilir. eOutDown da gelecek
*/
$(document).bind('keyup click', function (e) {
	/*
		Enter 'a basılıp basılmadığını anlamak için e 'yi ve daha doğrusu eOutUpClick 'u kullanmayı düşünüyorum.
		1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
			eOutUpClick = e;
	*/
	Tar = getTar();
	setoldTar();
	setTar();
	TarSib = getSib(Tar);
	/* 1607301205 getSib 'e fonksiyonalize oldu
	var childNodeIndex = 0; //ilki textNode ise sonrakine bak
	if (Tar.childNodes[childNodeIndex].nodeType == 3) {
		childNodeIndex++;
	}
	//
		//1507130900
		//if (Tar.childNodes[childNodeIndex].color == '#0000ff') {
		//gibi bir if clause eklemek zorundayım. Yoksa
			//Uncaught TypeError: Cannot read property 'length' of undefined 
		//hatasi geliyor. 
	//
	
	if (Tar.childNodes[childNodeIndex].color == '#0000ff') {
		TarSib = Tar.childNodes[childNodeIndex].childNodes[childNodeIndex].childNodes[childNodeIndex];
	} else {
		TarSib = Tar.childNodes[childNodeIndex].childNodes[childNodeIndex];
	}
	*/
	if (TarSib.innerText.length == 10 || TarSib.innerText.length == 9) {
		cssObj.colors.current = cssObj.colors.default;
		autoNow()
	} else {
		//if (typeof window.external == 'object') {
		if (WiNcapable) {
			// Uncaught TypeError: Object [object Object] has no method 'DoEvents' 
			// window.external.DoEvents();  //duzgun calismiyor
			cssObj.colors.current = cssObj.colors.WiNcapable; /*1602091036 yellow dan değiştirdim*/; //Normalde LightYellow 'du (Büyük harf küçük harf önemli mi bilmiyorum ama sanmıyorum)
			/*
				LightYellow 'u kabul etmeyen yellow 'u kabul ediyor. Çok da üstelemeyeceğim şimdilik. 
			*/
		} 
		/*
			Buraya öyle bir kod gelecek ki, sadece Yap.Bil değil, bir Array 'den
			Tümünü seçecek. Bu sefer substr olay biraz değişecek. 
			6 dan başlayacak fakat, 7 adet gitmeyecek.
			sonuna kadar veya sonraki boşluğa kadar veya
			sonraki noktalama işareti kombinasyonuna kadar gidecek.
			Mesela diyelim ki,
			Kay.Par.Har( dediğinde ( 'e kadar olan bölümü alıp
			Matrisinde var mı diye bakacak. 
			Matrisinde var ise, renk değişir. 
			Diyelim ki renk değişti ve komut için gerek herşey tamam
			Ondan sonra PC de ise işleme koyar.
			PC de değilse, işleme koymayacak ancak 
			Sonraki PC 'de açılımda bunların pending-operations olarak
			çalışacağını bilecek. Oraya gelince devreye girecek. 
			herhangi bir komut yazıldığında bu komut illa 
			başka bir nota gönderme yapmak zorunda değil direk
			aynı zamanda bu eklenen komut haricen bir javascript kodunun
			çalışmasını da sağlayabilir. Hatta öncelikle bunu sağlayabilir.
			Normalde tüm kodlar tüm notlarda olmak zorunda değil. 
			Mümkünse büyük bir kısmı sonradan eklenmeli bence.
			Ajax Calls vs vs bunun için kullanılabilir.
			Başlangıçta sadece bu alt yapı için gereken kod eklenmeli
			Onun dışındakiler biraz Hover vs görsellik click vs
			Bunlar dışındakilerin her not içinde eklenmesi gereksiz
			---
			Şimdi takip ettiğim kadarıyla, bütün window.external 'ları WiNcapable ile değiştirdiğime göre devam edebilirim.
			Şimdi aşağıdaki süreçte Yap.Bil çalışılmış. Ancak bariz bir deneysellik var. Şimdi bunu tüm süreçlere yaymak lazım.
			Bunun üzerinde düşüneceğim.
			---
			Şimdi substr(6) ile ilk 6 atıldı. '(' e kadar olan kısım var mı yok mu diye baktık. Buraya kadar sorun yok. 
			Sonra ''' e göre split yaptık. sonra ')' unu görürsek sorun yok. görürsek işlem başlar. 
			---
			Hemen hatırlatayım normalde ben bu işlemi daha sonra halledecektim. Ancak, birkaç gerekçe ile öne aldım.
			gDrive ile dışarıdan js yükleme problemi çözüldü
			font-height büyütme mahremiyeti sekteye uğrattığından adjustable gerekliliği çıktı ortaya
			bunu adjust eyleminin de cmdArr vasıtasıyla halledilmesini istiyorum.
			---
			Bu arada zaman açısından şu da olabilir. Normalde bi cmdArr basıldığında arka planda yükleme gerçekleşir
			Sonra sen parametreleri girerken, bir yandan da yükler.
		*/
		cmdTxtJob(TarSib);
	}
});

/*
	1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
		var cmdTxtOut; //Kontrol Değişkeni
		var nextTxtOut; //Kontrol Değişkeni
		var nextTxtYedek; //nextTxtOut 'un yedeği
		var nextTxtOutYedek; //nextTxt 'ın  yedeği
*/
var enteringParamAra; //Yani Ara Parametre giriliyor boolean değişkeni.
var enteringParamSon; //Yani Son Parametre giriliyor boolean değişkeni. 
function cmdTxtJob(locTarSib) {
	var cmdTxt = [];
	/*
		1412051316_HTML ICINDEKI CODE.html versiyonunda 'n sonra gerek yok
			//cmdTxtOut = cmdTxt; //Kontrol Değişkeni Assign oldu
	*/
	/*
		Bu işleyişin değişmesini istiyorum ancak daha tam olarak kurgulamış değilim. 
		Ben şimdi aklımdan geçenden bahsedeyim, olup olmayacağı biraz da programın yapısı ile alakalı.
		Herhangi bir cmdInstance girildiği anda, program kendisi parantezi açarsa 
		ve ardından ilk ayıraç amaçlı ' tırnak veya " çift tırnak veya "'" tırnak koyarsa
		o zaman sadece talep edilen datayı girmek kalır kullanıcı Serhat 'a.
		Ve iOS ortamında Geç/Enter/Return tuşuna basarak ilerleme imkanı sağlarsak,
		o zaman herhangi bir cmdInstance 'ı girmek fena halde kolay bir hale gelir.
		Zaten büyük harf/küçük harf problemini çözdük. Aynı zamanda boşluk problemini de çözdük.
		Şimdi geriye bu kolaylaştırma kaldı.
		---
		String.fromCharCode(39) + String.fromCharCode(34) + String.fromCharCode(39) => '"'
		---
		Bunu devreye sokmadan önce, parantez açmayı ve tırnak açmayı sağlamam gerekiyor.
		Öncelikle bence parantez açmayı sağlayalım.
			Onu sağlamadan önce veriAyirac diye bir değişken tanımlayıp Sürekli onun üzerinden devam edelim.
	*/
	var veriAyirac = /*String.fromCharCode(39);*/ String.fromCharCode(39) + String.fromCharCode(34) + String.fromCharCode(39);
	cmdTxt[0] = locTarSib.innerText; //elProcOut.parentElement.innerText.split(')')[0]
	/*
		TarSib.innerText yerine TarSibTxt 'nin işletilmesi lazım. 
		Karar değiştirdim. artık direk TarSib 'i locTarSib olarak içeriye alacağım. 
		---
		Veya Optional Parametre girilir. Eğer sadece Text ve paramArray.length = 1 ise o zaman direk tarSib alır geçer
		Öbür türlü Tarsib girildi ise, Tarsib in yerine ne geldiyse o. 
	*/
	cmdTxt[1] = cmdTxt[0].substr(6);
	cmdTxt[2] = cmdTxt[1].split(' ')[0];
	cmdTxt[3] = cmdTxt[2].split('(')[0];
	/*
		normalde önce ' ' sonra '(' split ediliyor. Acaba bu boşluk probleminin sebebi mi?
	*/
	/*
		Bu noktada cmdTxt[5] ve sonrasındaki olay şu,
		otomatikman ilk harfin büyük diğerlerinin küçük olmasını sağlamaya çalışıyorum. 
		Ancak bu da olmaz. Çünkü WiNjs de 3üncü harf de büyük. Başka bir çözüm bulmak lazım.
		---
		Bunu çözmenin yolu 
		for (var i=0;i<cmdArr.length;i+=2){console.log(cmdArr[i])}
		Bunu kullanmak. Yani Sadece text kısımları almak olabilir. Ancak bundan başka da çözüm var.
		Mesela sadece string olanları alabiliriz.
		---
		Bir çözüm yolu da sadece stringlere bakmak. Veya sadece object olmayanlara bakmak.
		for (var i=0;i<cmdArr2.length;i++){if (typeof cmdArr2[i] !== 'object') {console.log(cmdArr2[i])}}
		---
		Aynı zamanda büyütmek da mantıklı olduğu için
		for (var i=0;i<cmdArr.length;i++){if (typeof cmdArr[i] !== 'object') {cmdArr2.push(cmdArr[i].toUpperCase())}}
		---
		Yalnız bunu da beğenmedim. Neden dersen indexOf kaç çıkarsa diğerinde de o çıksın istiyorum.
		Yani hep çift sayı versin.
		---
		var cmdArr2=[];for(var i=0;i<cmdArr.length;i++){if(typeof cmdArr[i]!=='object'){cmdArr2[i]=cmdArr[i].toUpperCase()}}
		Bu istediğime beni ulaştırmış gibi gözüküyor. Şimdi bu Code daha kullanışlı bir hale getirelim. 
	*/
	cmdTxt[5] = [];
	for (var cmdTxtEvenCounter = 0; cmdTxtEvenCounter < cmdArr.length; cmdTxtEvenCounter++ ) {
		if (typeof cmdArr[cmdTxtEvenCounter] !== 'object') {
			cmdTxt[5][cmdTxtEvenCounter] = cmdArr[cmdTxtEvenCounter].toUpperCase();
		}
	}
	//cmdTxt[4] = cmdArr.indexOf(cmdTxt[3]);
	cmdTxt[4] = cmdTxt[5].indexOf(cmdTxt[3].toUpperCase());
	/*
		İleride unuturum diye özellikle belirtmek istiyorum.
		Bu cmdTxt[5] 'i ilave ederek küçük harf-büyük harf sorunundan kurtulmuş oldum. 
	*/
	//if (cmdArr.indexOf(TarSib.innerText.substr(6).split(' ')[0].split('(')[0]) > -1) {
	if (cmdTxt[4] > -1) {
		/*
			Şimdi bu noktada parantezin ve veriAyirac 'ın yani tırnak işaretinin otomatik gelmesini istiyoruz.
			Ancak, nasıl anlamasını sağlayacağız
		*/
		if (cmdTxt[1].length == /*cmdTxt[5][cmdTxt[4]]) {*/ cmdArr[cmdTxt[4]].length) {
			/*
				cmdTxt[5][cmdTxt[4]] neden işe yaramadı? veya
				cmdTxt[5][cmdTxt[4]].length neden işe yaramayacaktı? Normalde, birer arayla sırayı bozmadan txt değerleri
				içine matrislemekten başka ne işe yarıyordu ki cmdTxt[5]?
			*/
			console.log('Daha yeni cmdInstance komutu tamamlandi.');
			enteringParamAra = false; //Parametre giriliyor olamaz cmdInstance daha yeni tamamlandı ise
			enteringParamSon = false;
			locTarSib.innerText += '(' + veriAyirac;
			/*
				Eğer herşey yolunda giderse, Veri uygun birşekilde girilirse, peşine parantez ve tırnak ekleyecek.
				Kod çalışıyor gibi görünüyor. Buna ilaveten bir de collapse özelliği eklemek gerekiyor.
			*/
			var sel = document.getSelection();
			sel.collapse(locTarSib,1);
			/*
				Şu anda
				if (cmdTxt[6].length > paramAdet * 2) {
				} else 'sinde,
					şu code var.
						var nextTxt = $(Tar).next().children().children();
						nextTxt.text(nextTxt.text() + '{' + eOutUpClick.keyCode + '}' + '[' + eOutDown.keyCode + ']');
					Bu code çalışıyor çalışmasına fakat, Enter 'a basıldığında haliyle Tar değiştiği için, iş karışıyor. 
					Bundan dolayı Tar sonucunda oluşan nextTxt değişkeninin Global olmasını istiyorum ve ilavaten,
					Bunun tanımlanmasının (' ın eklendiği anda yapılmasını istiyorum.
					---
					Birazdan, nextTxt 'i buraya alacağım ancak, gerçekten Tar Dan mı veya $(Tar) 'dan mı çıkmamız gerekiyor.
					Tar veya $(Tar) 'ın alternatifi var mı? 
					Şimdilik yok kabul edip, Tar 'dan çıkmaya devam edeceğim. 
					---
					nextTxt yerine nextTxtOut kullanmayı düşünüyorum
			*/
			/*
				1412051316_HTML ICINDEKI CODE.html versiyonunda
					keyup Enter 'ı {13}[13] şeklinde yakalayamayınca çözümü
						if (cmdTxt[1].length == //cmdTxt[5][cmdTxt[4]]) {// cmdArr[cmdTxt[4]].length) { içine
							nextTxtOut = $(Tar).next().children().children();
							nextTxtOutYedek = $(Tar).next().children().children();
					de aramıştım. keyup 'ın enter tuşu release olduktan sonra fire olduğunu farkedince anlamını yitirdi gibi..
			*/
		} 
		cssObj.colors.current = cssObj.colors.enteringParam;
		var paramAdet = cmdArr[cmdTxt[4]+1][0];
		/*
			cmdTxt[2] 'den split '(' yapınca boşluktan sonrasını almıyor. Bundan dolayı aklıma gelen ilk çözüm
			cmdTxt[2] yerine cmdTxt[1] den almak.
			Ancak bunu yaptığım zaman ilave problemler çıkar mı kestiremiyorum.
			Neden ilave problemler çıkar diye bekliyorsun dersen, mesela contenteditable=false kısımdan veya 
			ondan sonrasında düz yazı varsa onun içindeki ' tırnak işaretinden ilave problemler doğar mı doğmaz mı
			bunları kestiremiyorum. Ancak denemekten zarar geleceğini de sanmıyorum.
			Bundan dolayı en azından geçici olarak;
				cmdTxt[5] = cmdTxt[2].split('(')[1];
					yerine
				cmdTxt[5] = cmdTxt[1].split('(')[1];
					yapmayı düşünüyorum.
		*/
		cmdTxt[5] = cmdTxt[1].split('(')[1]; //cmdTxt[5] = cmdTxt[2].split('(')[1];
		cmdTxt[6] = cmdTxt[5].split(veriAyirac);
		/*
			Ayıraç olarak kullandığım ' ve " nin karakter kodlarına ihtiyaç duyarsam diye
			buraya koymayı düşünüyorum. 
		*/
		if (cmdTxt[6].length > paramAdet * 2) {
			cssObj.colors.current = cssObj.colors.finishedParam;
			enteringParamAra = false; //Tüm tırnaklar tamamlandıysa da Parametre giriliyor olamaz.
			enteringParamSon = false; //tüm ara false olan yere son false eklenmeli mi
			cmdTxt[7] = [];
			for (var sayaci = 0;sayaci < cmdTxt[6].length;sayaci++) {
				if (sayaci % 2 == 1) {
					cmdTxt[7].push(cmdTxt[6][sayaci]);
				}
			}
			/*
				Şimdi artık burada mantığı biraz düşünmek lazım.
				Birkaç temel sorum var, unutma ihtimallerine karşılık
				cmdArrRet ' e ne zaman girecek ne zaman girmeyecek?
				.lateProcess 'i mi kontrol edecek? Yoksa benim işim bitti işaretini mi kontrol edecek? 
				Mesela .lateProcess yerine ltPrcS01S_DONE bulduğunda artık bu eleman tamamen ıskartaya ayrılmış olacak
				Ancak ltPrcS01S_DONE yoksa demekki bir şekilde halen işleme girmesi gerekiyor.
				Ancak burada başka sonuçlar var.fnc Return ettiğinde bir true false göndermemeli
				bir obje veya matris göndermeli. veya kolaylık olsun diye başlangıçta string array gönderebilir.
				Gelen cevaba göre olay devam eder. 
				Gelen cevap neler ihtiva etmeli?
				Şimdilik çok fazla şey içermesini istemiyorum. Hatta şimdilik sadece oldu veya olmadı olsun.
				Yani DONE veya değil. Eğer DONE ise veya bunun ismine jobDone diyelim. 
				Eğer başarıyla sonuçlandıysa, jobDone diye bir class gelecek. Bu class var ise artık denekki
				bu işleme girmesi gereken bir cmd değil. Ancak tıklayarak bazı opsiyonları üzerinde oynama şansımız olabilir.
				Tıklandığında jobDone olmasına rağmen tekrar oneMoreTime veya Repeat falan gibi birşey gelebilir.
				repeatMultiTime gibi. jobDone 'a alternatif oldukları için, oneMoreTime veya repeat olduğunda,
				tekrar tıklandığında, tekrar yapacak anlamına geliyor. 
				
			*/
			if (typeof $(locTarSib).find('.' + WiNcapStr[8] /* eski adı => '.lateProcess'*/)[0] == 'object') {
				if (locTarSib != TarSib) { //Bunu neden koyduğumu şuan için hatırlamıyorum
					cmdArrRet(cmdArr[cmdTxt[4]+1][1](cmdTxt[7]),locTarSib);
				}
			} else {
				cmdArrRet(cmdArr[cmdTxt[4]+1][1](cmdTxt[7]),locTarSib);
			}
		} else {
			/*
				else 'den itibaren demek ki tüm parametreler girilmemiş anlamına geliyor. 
				eOut ile çalışmaya çalışacağım.
				Enter 'a basıldığında cancel etmek lazım.
			*/
			/*
				1412051316_HTML ICINDEKI CODE.html versiyonunda
					Enter tuşunu suppress etmek veya prevent etmek için (şimdiki bilgim dahilinde konuşuyorum)
					keydown veya keypress event 'ını handle etmem gerektiğini öğrendim. (ileride aksini de öğrenebilirim)
					ben de vakti zamanında keydown veya keyup 'tan birinden vazgeçmeye karar vermiştim. O dönemde keydown 'dan vazgeçmiştim.
					Şimdi gördüğüm kadarıyla keydown 'a ihtiyacım oldu.
					---
					keyup 'ı keydown ile değiştirmek mantıklı değil çünkü tam hatırlamasam da, vakti zamanında çok mantıklı gerekçelerle
					keydown 'ı seçmedim.
					---
					Bundan dolayı şimdi keydown için ayrı bir code açmak zorundayım. 
					Ben tabi bu zorunluluğunun farkına varıncaya kadar, bir sürü code yazdım. Şimdi o code 'lar anlamını
					büyük oranda yitirmiş görünüyor. Ancak tam anlamıyla yaptıklarımı geri alıp bir versiyon gerilemesine gitmek
					yerine onları burada toplamayı düşünüyorum. 
						Alttan başlayalım.
							if (cmdTxt[6].length > paramAdet * 2) {} else {} kısmını ekliyorum
								var nextTxt = $(Tar).next().children().children(); //Bunun yerine nextTxtOut 'a geçebilirim.
								nextTxtYedek = $(Tar).next().children().children();
								if (nextTxtYedek == nextTxtOutYedek) {console.log('nTxtYdk == nTxtOutYdk')} else {console.log('nTxtYdk != nTxtOutYdk')}
								nextTxt.text(nextTxt.text() + '{' + eOutUpClick.keyCode + '}');
								nextTxtOut.text(nextTxtOut.text() + '[' + eOutDown.keyCode + ']');
								//Şimdi buraya basılan tuşun code 'u gelecek.
								//$(Tar).next().children().children().text($(Tar).next().children().children().text() + '.! !.')
			*/
			enteringParamAra = true; //Tırnaklar tamamlanmadıysa parametre giriliyor olabilir ancak ya Tırnak arasında değil virgüldeysek ne olacak?
			if (cmdTxt[6].length == paramAdet * 2) {
				enteringParamSon = true;
			} else {
				enteringParamSon = false;
			}
		}
		/*
			Yap.Bil 'in özel durumuna şimdilik karışmıyorum. Bu geçiş süreci için gerekliydi.
			Geçiş tamamlanıncaya kadar Yap.Bil 'in deneysel çalışması her ne kadar premature ve gelişmemiş olsa da
			varlığını sürdürecek.
			--------------------------
			Yakında buna Yap.Bil özel durumuna ihtiyacım kalmayacak. Ama buna emin oluncaya kadar varlığını sürdürmeye devam etmeli.
		*/
		/*
		if (TarSib.innerText.substr(6,7) == "Yap.Bil") {
			col1 = 'PaleGreen';
			if (TarSib.innerText.split("'").length > 8) {
				col1 = 'Cyan';
				var TarSibSib;
				var TarSibSibId;
				var TarSibSibText;
				//if (typeof window.external == 'object') {
				if (WiNcapable) {
					TarSibSibId = 'winext_true';
					TarSibSibText = 'Not Processed created Win';
				} else {
					TarSibSibId = 'winext_false';
					TarSibSibText = 'Not Processed created iOS';					
				}
				if (typeof $(TarSib).find('.lateProcess')[0] == 'object') {
					TarSibSib = $(TarSib).find('.lateProcess')[0];
				} else {
					TarSib.innerHTML += ',<span style="background-color:Orange; border-radius: 5px;" contenteditable="false" class="lateProcess" id="' + TarSibSibId + '">' + TarSibSibText + '</span>)';
					TarSibSib = $(TarSib).find('.lateProcess')[0];
				}
			}
		}
		*/
	} else {
		enteringParamAra = false; //cmdArr 'de olmayan bir yazı ise de Parametre giriliyor olamaz.
		enteringParamSon = false;
	}
}

function cmdArrRet(fncRet, loc2TarSib) {
	/*
		Normalde fncBool diyecektim ancak sonradan vazgeçtim. Bunun nedeni,
		şimdilik function 'lar bool döndürse de, ileri de hata mesajı veya başka şeyler de döndürmesi gerekebilir.
		Bundan dolayı function return yani fonksiyonun döndürdüğü anlamında fncRet diyorum.
		---
		Biz bu kodlar karmaşıklaştıkça jsOOP 'e (JavaScript Object Oriented Programming) geçmek zorunda kalabiliriz. 
		Hatta kalabiliriz iyimser oldu, kalmak zorunda kalacağız gibi görünüyor.
		Bu konu ile ilgili dün birkaç site gezdim. Javascript OOP adıyla Google Chrome Bookmarks 'ta var.
		http://www.objectplayground.com/ adlı bir sitede obje denemesi de yapılabiliniyor.
	*/
	//console.log('if (fncRet) içine girilecek');
	if (fncRet) {
		var TarSibSib;
		var TarSibSibId;
		var TarSibSibText;
		//if (typeof window.external == 'object') {
		//console.log('if (WiNcapable) içine girilecek');
		if (WiNcapable) {
			console.log('if (WiNcapable) icine true ile girildi');
			TarSibSibId = WiNcapStr[0] + '_' + WiNcapStr[1]; //WiNcapable_true
			/*
				Bunları buradan elle değiştirme bence. Globale bir değişken atayalım. Tüm programlar ona baksın ona göre çalışsın. 
				Belki başka yerde de winext_true var. Şimdi teker teker onları aramayalım. 
				Çünkü burada yaptığım değişiklikler yine üzerine defalarca değişiklik yapmaya çok müsait. 
				Daha kafamda kavram tam olarak oluşmadı diyebiliriz. 
			*/
			TarSibSibText = WiNcapStr[3] + ' ' + WiNcapStr[4] + ' ' + WiNcapStr[5] + ' ' + WiNcapStr[6]; //'Not Processed created Win';		
		} else {
			console.log('if (WiNcapable) icine false ile girildi');
			/*
				
			*/
			TarSibSibId = WiNcapStr[0] + '_' + WiNcapStr[2]; //WiNcapable_false
			TarSibSibText = WiNcapStr[3] + ' ' + WiNcapStr[4] + ' ' + WiNcapStr[5] + ' ' + WiNcapStr[7]; //'Not Processed created iOS';					
		}
		//console.log('if (WiNcapable) içinden çıkıldı');
		/*
			Bildiğim kadarıyla birden fazla ID 'si olamaz bir tag 'in ancak birden fazla class 'ı olabilir. Bundan dolayı,
			Eğer bu bildiğim doğruysa, o zaman birden fazla class ekleyerek class ları sanki birer attribute 'muş gibi kullanabiliriz.
			Mesela diyelim ki, ltPrcS01S diye bir ön takı olsun. Ondan sonraki class 'lar şu şekilde olsun mesela
			ltPrcS01S_iOS veya ltPrcS01S_Win veya ltPrcS01S_notProcessed veya ltPrcS01S_Processed gibi.
			Tüm elemanlarda ltPrcS01S olacak. Ardından diğer Classlar duruma göre olacaklar. 
			Buradaki amaç şu,
			Not ilk açıldığında Class 'a göre sorgu yapıldığında kimlerin iOS 'ta oluştuğunu bileceğiz ki,
			Onların işlemlerinin yerine gelmediğini varsayıp, o işlemi tekrar yaptıracağız. Mesela Harcamaların yazılması gibi.
		*/
		//console.log('if (typeof..) içine girilecek');
		if (typeof $(loc2TarSib).find('.' + WiNcapStr[8] /* eski adı => '.lateProcess'*/)[0] == 'object') {
			console.log('if (typeof..) icine true ile girildi');
			TarSibSib = $(loc2TarSib).find('.' + WiNcapStr[8] /* eski adı => '.lateProcess'*/)[0];
			TarSibSib.style.backgroundColor = 'yellow'; //Debug amaçlı. Sonradan silebilirsin.
			/*
				Şimdi burada renklendirmek yerine, değişiklik yapmamız lazım. Değişiklik ne olacak dersen, 
				Renklendirmek yerine içine girip yazısını değiştireceğiz.
				Ayrıca id 'sini değiştireceğiz. Böylelikle işlem yapıldıktan sonra tekrar yapılmamasını
				sağlamış olacağız. Ancak yine de renk değişikliği illa yapmak istiyorsak, kırmızı kalabilir.
			*/
			TarSibSib.id = WiNcapStr[0] + '_' + WiNcapStr[1];
			TarSibSib.innerText = WiNcapStr[3] + ' ' + WiNcapStr[4] + ' ' + WiNcapStr[5] + ' ' + WiNcapStr[6];
		} else {
			//console.log('if (typeof..) içine false ile girildi');
			//TarSib.innerHTML += ',<span style="background-color:Orange; border-radius: 5px;" contenteditable="false" class="' + WiNcapStr[8] /*lateProcess*/ + '" id="' + TarSibSibId + '">' + TarSibSibText + '</span>)';
			/*
				Belki ilk bakışta çok gerekli gelmeyebilir ancak, bence TarSib innerHTML içine eklenik metin şeklinde eklemek yerine DOM üzerinden
				eklemek daha mantıklı. Bu şekilde yaparsak yani DOM üzerinden yaparsak, yönetme açısından faydalı olacağını düşünüyorum.
				Ancak bundan önce birkaç deneme yapmam lazım. Bu denemeleri başlatmak için bence TarSib 'i dışarı almak lazım. 
			*/
			TarSibOut = loc2TarSib; // TarSibOut 'a sanırım gerek yokmuş. Zaten global olduğu için Console 'a geliyor çağırdığında.
			/*
				Sıralamaya göre gidiyorum
					contentEditable:
					================
						TarSibOut.children[0].contentEditable = 'false';
							*	Style içinde contentEditable ile dışarıda eklemek arasında fark var mı? Bu araştırılmalı mı?
					Style CSS Kısmı:
					================
						TarSibOut.children[0].style.backgroundColor = 'orange';
						TarSibOut.children[0].style.borderRadius = '5px';
					Class Kısmı:
					============
						http://stackoverflow.com/questions/7388626/how-do-i-add-a-class-to-the-html-element-without-jquery
							classList returns a token list of the class attribute of the element.

							classList is a convenient alternative to accessing an element's list of classes as a space-delimited string via element.className. It contains the following methods:

							add - Adds a class to an element's list of classes. If class already exists in the element's list of classes, it will not add the class again.
							remove - Removes a class from an element's list of classes. If class does not exist in the element's list of classes, it will not throw an error or exception.
							toggle - Toggles the existence of a class in an element's list of classes
							See below about the optional second argument.
								http://stackoverflow.com/questions/23663151/whats-the-point-of-the-second-argument-in-element-classlist-toggle
							contains - Checks if an element's list of classes contains a specific class
							---
							Toogle olayını değerlendirmek gerek. Ama ondan önce Force olayını değerlendirmek gerek. 
					ID Kısmı:
					=========
						TarSibOut.children[0].id
				---
				Buna göre kod şu şekilde olmalı sanırım.
					TarSibOut.children[0].style.backgroundColor = 'orange';
					TarSibOut.children[0].style.borderRadius = '5px';
					TarSibOut.children[0].contentEditable = 'false';
			*/
			var newTarSibSib = loc2TarSib.ownerDocument.createElement('span');
			loc2TarSib.appendChild(newTarSibSib);
			newTarSibSib.style.backgroundColor = 'orange';
			newTarSibSib.style.borderRadius = '5px';
			newTarSibSib.contentEditable = 'false'; //Style içinde olmasının bir farkı var mı?
			newTarSibSib.className = WiNcapStr[8];
			newTarSibSib.id = TarSibSibId;
			newTarSibSib.innerText = TarSibSibText;
			//console.log('TarSibOut TarSib e eşitlendi');
			TarSibSib = $(loc2TarSib).find('.' + WiNcapStr[8] /* eski adı => '.lateProcess'*/)[0];
		}
		//console.log('if (typeof..) içinden çıkıldı');
	}
	//console.log('if (fncRet) içinden çıkıldı');
/*Burada bir yerde ikinci kez girildiğinde WiNcapable_true sağlamamız gerekiyor*/
}

function autoNow() {
	if (isToday()) {
		if (TarSib.innerText.length == 10 || TarSib.innerText.length == 9) {
			var myRepeat = TarSib.innerText.length - 6;
			if (TarSib.innerText.substring(7,10) == '...' || TarSib.innerText.substring(7,9) == '..') {
				var dHour = twoDigit(dDate.getHours());
				var dMinute = twoDigit(dDate.getMinutes());
				var newTime = dHour + ':' + dMinute;
				TarSib.innerText = newTime + ' A' + Array(myRepeat).join('.'); //Çalışırsa eğer A... veya A.. duruma göre yerleştircek
				var sel = document.getSelection();
				sel.collapse(TarSib,1); //TarSib objesinin 1 ise sonuna 0 ise başına cursor 'ü sürükler
			}
		}
	} else {
	};
}

function isToday() {
	var titleDay = document.title.substring(0, document.title.indexOf(" ") - 4);
	var retGen = retGenDec_dDt();
	return (titleDay == retGen) 
}
var defDivExtYeniUsul = true; //istersen true yap dışarıdan alsın(Yaptım 1611291338)
function getTar() {
	//*1507130900*/console.log('function getTar() {started}');
	var yerTar /*yerelTar*/ = document.getSelection().getRangeAt(0).startContainer;
	while (yerTar.parentNode.tagName != 'BODY') {
		yerTar = yerTar.parentNode;
	};
	/*
		Son 3 KoyuMaviSaat Div kaldığında bunun bilmesi gerekiyor. 
	*/
	if ($('body>div').length - $(yerTar).index() < 7) {
	
		var childNodeIndex = 0; //ilki textNode ise sonrakine bak
		if (/*1507130900 hata düzeldi*/yerTar/*Tar yerine yerTar yaptım*/.childNodes[childNodeIndex].nodeType == 3) {
			childNodeIndex++;
		}
		// 1607301205 getSib 'e fonksiyonalize olaMAdi
		if	(/*yerTar.childNodes[childNodeIndex].color == "#0000ff"*/yerTar.childNodes[childNodeIndex].style.color == 'rgb(0, 0, 255)') {
			/*
				Bazen neden bilmiyorum ama bu başarısız oluyor. Bundan dolayı bence bir kod daha eklemek lazım. Daha doğrusu bu kodu değiştirmek lazım.
				Bence direk dHourExt ve dMinuteExt diye bir kavram olmasın. Direk bu değerleri '00' ve '00' alsın.
				Bence burada Try Catch tarzı bir kodlama çalışır. Bunu eklemek lazım. Ondan sonra neden çalışmadığına bakarız ayrıca. 
			*/
			dDate = new Date();
			var dHourExt = twoDigit(dDate.getHours());
			var dMinuteExt = twoDigit(dDate.getMinutes());
			/*
				161128 - 1611280956
				Şu anda defDivExt Metin şekilde alıyor.
					var defDivExt = '\n\t<div>\n\t\t<font face=\"Segoe UI\" color=\"#0000ff\">\n\t\t\t<b>\n\t\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">' + dHourExt + ':' + dMinuteExt + ' A...<\/span>\n\t\t\t<\/b>\n\t\t<\/font>\n\t<\/div>\n\t<div>\n\t\t<font face=\"Segoe UI\">\n\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">a...<\/span>\n\t\t<\/font>\n\t<\/div>';
				Ben bazı değişikliklerden dolayı artık bunu harici bir htm dosyasından almasını istiyorum.
				O htm dosyası hazır. defDivOld.htm .
				Onu buraya eklemek için gereken kod;
				autLsynF = function(urlF) {
					with (new XMLHttpRequest()) {open('GET',urlF,false);send();return responseText}
				}
				getPF = function() {
					if (typeof urlPF != 'undefined') {
						return urlPF
					} else {
						return 'https://dl.dropboxusercontent.com/u/31117393/h1/iPlg/Today16/'
					}
				}
				autLsynHDoc = function(urlLF) {
					urlF = getPF()+ urlLF + '.htm';
					var docF = document.implementation.createHTMLDocument('');
					docF.documentElement.innerHTML = autLsynF(urlF);
					return docF;
				}
				var inBodyDoc = autLsynHDoc('defDivOld');
				$("body").append(inBodyDoc.body.innerHTML)
				//with (inBodyDoc.body) { //Bu kod kopyalamıyor, taşıyor.
					//for (var i = children.length -1; i > 0 ;i--) {
						//$("body").append(children[i]);
					//}
				//}
			*/
			var defDivExt;
			if (defDivExtYeniUsul) {
				autLsynF = function(urlF) {
					with (new XMLHttpRequest()) {open('GET',urlF,false);send();return responseText}
				}
				getPF = function() {
					if (typeof urlPF != 'undefined') {
						return urlPF
					} else {
						return 'https://dl.dropboxusercontent.com/u/31117393/h1/iPlg/Today16/'
					}
				}
				autLsynHDoc = function(urlLF) {
					urlF = getPF()+ urlLF + '.htm';
					var docF = document.implementation.createHTMLDocument('');
					docF.documentElement.innerHTML = autLsynF(urlF);
					return docF;
				}
				var inBodyDoc = autLsynHDoc('defDivOld');
				with (inBodyDoc.getElementsByTagName('span')[0]){
					innerText = innerText.replace('00',dHourExt);
					innerText = innerText.replace('00',dMinuteExt);
				}
				defDivExt = inBodyDoc.body.innerHTML;
				//Daha bitmedi dHourExt ve dMinute Ext 'i de alacak. Replace ilk Occurance 'ı alıyorsa,
				//Burada sırayla çalışır.
			} else {
				defDivExt = '\n\t<div>\n\t\t<font face=\"Segoe UI\" color=\"#00' + '00' + 'ff\">\n\t\t\t<b>\n\t\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">' + dHourExt + ':' + dMinuteExt + ' A...<\/span>\n\t\t\t<\/b>\n\t\t<\/font>\n\t<\/div>\n\t<div>\n\t\t<font face=\"Segoe UI\">\n\t\t\t<span data-wiz-span=\"data-wiz-span\" style=\"font-size: 9pt;\">a...<\/span>\n\t\t<\/font>\n\t<\/div>';
			}
			//$('body').html($('body').html() + defDivExt + defDivExt + defDivExt);
			/*
				1507081500 Bence 
				$('body').html($('body').html() + defDivExt + defDivExt + defDivExt);
				bu şekilde çalışmak yerine append prepend appendChild benzeri çalışmak lazım
				---
					
			*/
			$("body").append(defDivExt);
		}
	};
	return yerTar;
	/*
		Zaten Tar değişkeni Global. Tekrar return etmesende Global Tar değişiyor. Ne gerek var ki, tekrar return ediyorsun?
	*/
}
/*
	setOldTar ve setTar içinde bir de animate olmasını istiyorum. Bu animate text font 'u büyütecek. Bunu yaparken iki seçenek var.
	Bunlardan bir tanesi span içindeki style="font-size: 9pt;" 'ı animate şeklinde 11 yapıp çıkışta tekrar 9 yapmak. 
*/

/*
function setoldTar() {
	$(oldTar).css('border', 'none');
	$(oldTar).css('background-color', 'White');
	if (oldTar != Tar) {
		$(oldTar).find('span').animate({fontSize: "12px"}, 100);
	};
	oldTar = Tar;
}

function setTar() {
	$(Tar).css('border', '1px dashed gray');
	$(Tar).css('background-color', col1);
	if (Tar.childNodes[1].color = '#0000ff') {
		$(Tar).find('span').animate({fontSize: "24px"}, 100);
	} else {
		$(Tar).find('span').animate({fontSize: "18px"}, 100);
	}
}
*/

function setoldTar() {
	$(oldTar).css('border', 'none');
	$(oldTar).css('background-color', cssObj.colors.hovOuColor);
	if (oldTar != Tar) {
		$(oldTar).find('span').animate({fontSize: "12px"}, 100);
	};
	oldTar = Tar;
}

function setTar() {
	$(Tar).css('border', '1px dashed gray');
	$(Tar).css('background-color', cssObj.colors.current);
	var childNodeIndex = 0; //ilki textNode ise sonrakine bak
	if (Tar.childNodes[childNodeIndex].nodeType == 3) {
		childNodeIndex++;
	}
	// 1607301205 getSib 'e fonksiyonalize olaMAdi
	if (Tar.childNodes[childNodeIndex].style.color == 'rgb(0, 0, 255)') {
		$(Tar).find('span').animate({fontSize: setTar_fontSize + 'px'}, 100);
	} else {
		$(Tar).find('span').animate({fontSize: (setTar_fontSize * 0.875) + 'px'}, 100);
	};
}
var getSibYeniUsul = true;
function getSib(parSib) {
	/*
		getSib 'e fonksiyonalize olabilenler TarSib 'i isteyenler. (2 yerde)
		Renk e göre bool isteyenler aynen devam etti. (bu da 2 yerde)
		(Toplam 4 yerde kullanılmış bu mantık)
		Zaten bu olay birinde b tag var ya. birinde iç içe 3 eleman var
		Birinde iç içe 2 eleman var. Zaten font deprached oldu ya
		Komple bunlar değişse de olur
	*/
	/*
		161204 1612041339
		Yeni Usul 'de SPAN buluncaya kadar derinleşir. İçeriği değiştirmeye daha müsait.
	*/
	if (getSibYeniUsul) {
		return parSib.getElementsByTagName('span')[0];
	} else {
		var childNodeIndex = 0;
		if (parSib.childNodes[childNodeIndex].nodeType == 3) {
			childNodeIndex++;
		}
		if (parSib.childNodes[childNodeIndex].color == '#0000ff') {
			return parSib.childNodes[childNodeIndex].childNodes[childNodeIndex].childNodes[childNodeIndex];
		} else {
			return parSib.childNodes[childNodeIndex].childNodes[childNodeIndex];
		}	
	}
}

</script>
